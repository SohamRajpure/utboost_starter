[
  {
    "instance_id": "matplotlib__matplotlib-25311",
    "model_patch": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..d309693bf6 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -93,6 +93,34 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __getstate__(self):\n+        \"\"\"Get state for pickling.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable attributes\n+        for key in ['canvas', '_c1', 'cids', 'ref_artist', 'offsetbox']:\n+            state.pop(key, None)\n+        # Save legend reference and settings\n+        state['_legend_ref'] = self.legend\n+        state['_use_blit'] = self._use_blit\n+        state['_update'] = self._update\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state after unpickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore the legend reference\n+        self.legend = state['_legend_ref']\n+        # Wait for the legend to be fully unpickled and initialized\n+        if hasattr(self.legend, '_legend_box'):\n+            # Reinitialize the draggable functionality\n+            self.__init__(self.legend, use_blit=state['_use_blit'], update=state['_update'])\n+        else:\n+            # Store initialization parameters for later\n+            self._init_params = {\n+                'use_blit': state['_use_blit'],\n+                'update': state['_update']\n+            }\n+\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\n@@ -1208,6 +1236,54 @@ class Legend(Artist):\n         \"\"\"Return ``True`` if the legend is draggable, ``False`` otherwise.\"\"\"\n         return self._draggable is not None\n \n+    def __setstate__(self, state):\n+        \"\"\"Restore state after unpickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Store draggable state for later restoration\n+        if self._draggable is not None:\n+            self._draggable_params = {\n+                'use_blit': self._draggable._use_blit if hasattr(self._draggable, '_use_blit') else False,\n+                'update': self._draggable._update if hasattr(self._draggable, '_update') else 'loc'\n+            }\n+            self._draggable = None\n+        \n+    def draw(self, renderer):\n+        \"\"\"Draw the legend.\"\"\"\n+        if not self.get_visible():\n+            return\n+        \n+        # Restore draggable state if needed, but only after figure is fully set up\n+        if (hasattr(self, '_draggable_params') and self._draggable is None and \n+            hasattr(self, 'figure') and self.figure is not None and\n+            hasattr(self.figure, 'canvas') and self.figure.canvas is not None):\n+            try:\n+                self.set_draggable(True, \n+                                 self._draggable_params['use_blit'],\n+                                 self._draggable_params['update'])\n+            finally:\n+                delattr(self, '_draggable_params')\n+        \n+        # if mode == fill, set the width of the legend_box to the\n+        # width of the parent (minus pads)\n+        fontsize = renderer.points_to_pixels(self._fontsize)\n+        if self._mode in [\"expand\"]:\n+            pad = 2 * (self.borderaxespad + self.borderpad) * fontsize\n+            self._legend_box.set_width(self.get_bbox_to_anchor().width - pad)\n+\n+        # update the location and size of the legend\n+        bbox = self._legend_box.get_window_extent(renderer)\n+        self.legendPatch.set_bounds(bbox.bounds)\n+        self.legendPatch.set_mutation_scale(fontsize)\n+\n+        if self.shadow:\n+            Shadow(self.legendPatch, 2, -2).draw(renderer)\n+\n+        self.legendPatch.draw(renderer)\n+        self._legend_box.draw(renderer)\n+\n+        renderer.close_group('legend')\n+        self.stale = False\n+\n \n # Helper functions to parse legend arguments for both `figure.legend` and\n # `axes.legend`:\n",
    "model_name_or_path": "devlo"
  }
]