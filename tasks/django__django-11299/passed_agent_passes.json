[
  {
    "instance_id": "django__django-11299",
    "model_patch": "diff --git a/check_constraint_comprehensive_test.py b/check_constraint_comprehensive_test.py\nnew file mode 100644\nindex 0000000000..5dfceb42dc\n--- /dev/null\n+++ b/check_constraint_comprehensive_test.py\n@@ -0,0 +1,113 @@\n+#!/usr/bin/env python\n+\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes', \n+        'django.contrib.auth'\n+    ],\n+)\n+django.setup()\n+\n+from django.db import models, connection\n+from django.test import TestCase\n+from django.db.models.query_utils import Q\n+from django.db.models.sql.query import Query\n+\n+class TestModel(models.Model):\n+    field_a = models.IntegerField(blank=True, null=True)\n+    field_b = models.IntegerField(blank=True, null=True)\n+    field_c = models.BooleanField(default=False)\n+    field_d = models.BooleanField(default=True)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+def check_sql_for_columns(testcase, sql, qualified=False):\n+    \"\"\"Test that columns in SQL are appropriately qualified or unqualified.\"\"\"\n+    table_name = '\"test_app_testmodel\"'\n+    \n+    # First check that no fully qualified names appear in the SQL\n+    # if we're expecting unqualified names\n+    if not qualified:\n+        testcase.assertNotIn(f'{table_name}.\"field_a\"', sql)\n+        testcase.assertNotIn(f'{table_name}.\"field_b\"', sql)\n+        testcase.assertNotIn(f'{table_name}.\"field_c\"', sql)\n+        testcase.assertNotIn(f'{table_name}.\"field_d\"', sql)\n+    \n+    # Now check for each field that does appear in the SQL\n+    for field in ['field_a', 'field_b', 'field_c', 'field_d']:\n+        # Skip if the field doesn't appear in the SQL at all\n+        if f'\"{field}\"' not in sql and f'{table_name}.\"{field}\"' not in sql:\n+            continue\n+            \n+        if qualified:\n+            # Field should be qualified with table name\n+            testcase.assertIn(f'{table_name}.\"{field}\"', sql)\n+        else:\n+            # Field should be just the column name without table\n+            testcase.assertIn(f'\"{field}\"', sql)\n+\n+class CheckConstraintTest(TestCase):\n+    def get_sql_for_q(self, q_object, simple_col=True):\n+        \"\"\"Helper to get the SQL for a Q object\"\"\"\n+        query = Query(model=TestModel)\n+        where = query.build_where(q_object)\n+        compiler = query.get_compiler(connection=connection)\n+        sql, params = where.as_sql(compiler, connection)\n+        print(f\"SQL: {sql}\")\n+        print(f\"Params: {params}\")\n+        return sql, params\n+    \n+    def test_simple_and_condition(self):\n+        \"\"\"Test a simple AND condition\"\"\"\n+        q = Q(field_a=1, field_b=2)  # AND condition\n+        sql, _ = self.get_sql_for_q(q)\n+        check_sql_for_columns(self, sql, qualified=False)\n+    \n+    def test_simple_or_condition(self):\n+        \"\"\"Test a simple OR condition\"\"\"\n+        q = Q(field_a=1) | Q(field_b=2)  # OR condition\n+        sql, _ = self.get_sql_for_q(q)\n+        check_sql_for_columns(self, sql, qualified=False)\n+    \n+    def test_complex_mixed_condition_1(self):\n+        \"\"\"Test a complex condition with AND inside OR\"\"\"\n+        q = Q(field_a=1, field_b=2) | Q(field_c=True)  # (a=1 AND b=2) OR c=True\n+        sql, _ = self.get_sql_for_q(q)\n+        check_sql_for_columns(self, sql, qualified=False)\n+    \n+    def test_complex_mixed_condition_2(self):\n+        \"\"\"Test a complex condition with OR inside AND\"\"\"\n+        q = Q(field_a=1) & (Q(field_b=2) | Q(field_c=True))  # a=1 AND (b=2 OR c=True)\n+        sql, _ = self.get_sql_for_q(q)\n+        check_sql_for_columns(self, sql, qualified=False)\n+    \n+    def test_very_complex_condition(self):\n+        \"\"\"Test a very complex nested condition\"\"\"\n+        # a=1 AND (b=2 OR (c=True AND d=False)) OR e=3\n+        q = Q(field_a=1) & (Q(field_b=2) | Q(field_c=True, field_d=False)) | Q(field_a=3)\n+        sql, _ = self.get_sql_for_q(q)\n+        check_sql_for_columns(self, sql, qualified=False)\n+    \n+    def test_condition_from_pr_description(self):\n+        \"\"\"Test the specific condition from the PR description\"\"\"\n+        q = Q(field_c=True, field_a__isnull=False) | Q(field_c=False)\n+        sql, _ = self.get_sql_for_q(q)\n+        check_sql_for_columns(self, sql, qualified=False)\n+\n+if __name__ == \"__main__\":\n+    # Run the test\n+    import unittest\n+    unittest.main()\ndiff --git a/check_constraint_migration_test.py b/check_constraint_migration_test.py\nnew file mode 100644\nindex 0000000000..72ba041bef\n--- /dev/null\n+++ b/check_constraint_migration_test.py\n@@ -0,0 +1,110 @@\n+#!/usr/bin/env python\n+\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes', \n+        'django.contrib.auth'\n+    ],\n+)\n+django.setup()\n+\n+from django.db import models, connection, migrations\n+from django.test import TestCase\n+from django.db.models.query_utils import Q\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.executor import MigrationExecutor\n+from django.db.migrations.state import ProjectState\n+\n+class TestConstraintModel(models.Model):\n+    field_1 = models.IntegerField(blank=True, null=True)\n+    flag = models.BooleanField(blank=False, null=False)\n+    \n+    class Meta:\n+        constraints = [\n+            models.CheckConstraint(\n+                check=models.Q(flag__exact=True, field_1__isnull=False) | models.Q(flag__exact=False),\n+                name='field_1_has_value_if_flag_set'\n+            ),\n+        ]\n+        app_label = 'test_app'\n+\n+class CheckConstraintMigrationTest(TestCase):\n+    def test_check_constraint_sql_generation(self):\n+        \"\"\"Test that the SQL generated for a CheckConstraint is correctly formatted.\"\"\"\n+        # Create a Query object\n+        from django.db.models.sql.query import Query\n+        query = Query(model=TestConstraintModel)\n+        \n+        # Get the check constraint\n+        constraint = TestConstraintModel._meta.constraints[0]\n+        \n+        # Check the SQL that would be generated\n+        sql = constraint._get_check_sql(TestConstraintModel, connection.schema_editor())\n+        \n+        # Print the SQL for visual inspection\n+        print(f\"Generated SQL for check constraint: {sql}\")\n+        \n+        # Check that the SQL doesn't contain qualified column names\n+        self.assertNotIn('\"test_app_testconstraintmodel\".\"field_1\"', sql)\n+        self.assertNotIn('\"test_app_testconstraintmodel\".\"flag\"', sql)\n+        \n+        # Check that it uses the unqualified format\n+        self.assertIn('\"field_1\" IS NOT NULL', sql)\n+        self.assertIn('\"flag\"', sql) \n+        \n+    def test_migration_operation_sql(self):\n+        \"\"\"Test the SQL generation for a Migration with AddConstraint.\"\"\"\n+        # Create a migration class with our operation\n+        class TestMigration(migrations.Migration):\n+            operations = [\n+                migrations.CreateModel(\n+                    name='TestConstraintModel',\n+                    fields=[\n+                        ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+                        ('field_1', models.IntegerField(blank=True, null=True)),\n+                        ('flag', models.BooleanField()),\n+                    ],\n+                ),\n+                migrations.AddConstraint(\n+                    model_name='testconstraintmodel',\n+                    constraint=models.CheckConstraint(\n+                        check=models.Q(models.Q(('field_1__isnull', False), ('flag__exact', True)), ('flag__exact', False), _connector='OR'),\n+                        name='field_1_has_value_if_flag_set'\n+                    ),\n+                ),\n+            ]\n+        \n+        # Get the SQL from the migration operation\n+        from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n+        schema_editor = connection.schema_editor().__class__(connection)\n+        \n+        # Get constraint from second operation\n+        constraint = TestMigration.operations[1].constraint\n+        \n+        # Get the SQL directly\n+        where_sql = constraint._get_check_sql(TestConstraintModel, schema_editor)\n+        print(f\"Constraint SQL: {where_sql}\")\n+        \n+        # Ensure the SQL doesn't have qualified table names\n+        self.assertNotIn('\"test_app_testconstraintmodel\".\"field_1\"', where_sql)\n+        self.assertNotIn('\"test_app_testconstraintmodel\".\"flag\"', where_sql)\n+        \n+        # It should have unqualified names\n+        self.assertIn('\"field_1\" IS NOT NULL', where_sql)\n+\n+if __name__ == \"__main__\":\n+    # Run the test\n+    import unittest\n+    unittest.main()\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex b99f03cd88..ba8fd98be0 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1338,7 +1338,7 @@ class Query(BaseExpression):\n             if isinstance(child, Node):\n                 child_clause, needed_inner = self._add_q(\n                     child, used_aliases, branch_negated,\n-                    current_negated, allow_joins, split_subq)\n+                    current_negated, allow_joins, split_subq, simple_col=simple_col)\n                 joinpromoter.add_votes(needed_inner)\n             else:\n                 child_clause, needed_inner = self.build_filter(\ndiff --git a/sqlite_migration_reproduction.py b/sqlite_migration_reproduction.py\nnew file mode 100644\nindex 0000000000..8f69c3d5f2\n--- /dev/null\n+++ b/sqlite_migration_reproduction.py\n@@ -0,0 +1,83 @@\n+#!/usr/bin/env python\n+\n+import os\n+import sys\n+import sqlite3\n+import tempfile\n+from pathlib import Path\n+\n+\"\"\"\n+This test directly reproduces the scenario described in the PR by executing \n+the actual SQL migration statements that would be run on SQLite.\n+\n+Before the fix, when executing a migration with a CHECK constraint that combines\n+AND and OR operators, the constraint SQL would contain a mix of qualified and\n+unqualified column names, causing the migration to fail.\n+\"\"\"\n+\n+# The SQL that would be generated with the bug:\n+BUGGY_SQL = \"\"\"\n+BEGIN;\n+--\n+-- Create model TestConstraint\n+--\n+CREATE TABLE \"app_testconstraint\" (\"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT, \"field_1\" integer NULL, \"flag\" bool NOT NULL);\n+--\n+-- Create constraint field_1_has_value_if_flag_set on model testconstraint\n+--\n+CREATE TABLE \"new__app_testconstraint\" (\"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT, \"field_1\" integer NULL, \"flag\" bool NOT NULL, CONSTRAINT \"field_1_has_value_if_flag_set\" CHECK (((\"new__app_testconstraint\".\"field_1\" IS NOT NULL AND \"new__app_testconstraint\".\"flag\" = 1) OR \"flag\" = 0)));\n+INSERT INTO \"new__app_testconstraint\" (\"id\", \"field_1\", \"flag\") SELECT \"id\", \"field_1\", \"flag\" FROM \"app_testconstraint\";\n+DROP TABLE \"app_testconstraint\";\n+-- This will break if any of the references inside the CHECK constraint use the old table name\n+ALTER TABLE \"new__app_testconstraint\" RENAME TO \"app_testconstraint\";\n+COMMIT;\n+\"\"\"\n+\n+# The fixed SQL after our change:\n+FIXED_SQL = \"\"\"\n+BEGIN;\n+--\n+-- Create model TestConstraint\n+--\n+CREATE TABLE \"app_testconstraint\" (\"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT, \"field_1\" integer NULL, \"flag\" bool NOT NULL);\n+--\n+-- Create constraint field_1_has_value_if_flag_set on model testconstraint\n+--\n+CREATE TABLE \"new__app_testconstraint\" (\"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT, \"field_1\" integer NULL, \"flag\" bool NOT NULL, CONSTRAINT \"field_1_has_value_if_flag_set\" CHECK (((\"field_1\" IS NOT NULL AND \"flag\" = 1) OR \"flag\" = 0)));\n+INSERT INTO \"new__app_testconstraint\" (\"id\", \"field_1\", \"flag\") SELECT \"id\", \"field_1\", \"flag\" FROM \"app_testconstraint\";\n+DROP TABLE \"app_testconstraint\";\n+ALTER TABLE \"new__app_testconstraint\" RENAME TO \"app_testconstraint\";\n+COMMIT;\n+\"\"\"\n+\n+def test_sql_migration(sql_statements):\n+    \"\"\"\n+    Test that the given SQL statements can be executed without errors.\n+    Returns True if successful, False otherwise.\n+    \"\"\"\n+    with tempfile.NamedTemporaryFile() as db_file:\n+        conn = sqlite3.connect(db_file.name)\n+        cursor = conn.cursor()\n+        try:\n+            cursor.executescript(sql_statements)\n+            return True, None\n+        except sqlite3.Error as e:\n+            return False, str(e)\n+        finally:\n+            conn.close()\n+\n+# Test the buggy SQL (should fail)\n+success_buggy, error_buggy = test_sql_migration(BUGGY_SQL)\n+print(f\"Buggy SQL test {'passed' if success_buggy else 'failed with error: ' + error_buggy}\")\n+\n+# Test the fixed SQL (should pass)\n+success_fixed, error_fixed = test_sql_migration(FIXED_SQL)\n+print(f\"Fixed SQL test {'passed' if success_fixed else 'failed with error: ' + error_fixed}\")\n+\n+# Validate the results\n+if not success_buggy and success_fixed:\n+    print(\"SUCCESS: The bug was reproduced and our fix works correctly!\")\n+else:\n+    print(\"ERROR: Test didn't behave as expected.\")\n+    print(f\"Buggy SQL succeeded: {success_buggy}\")\n+    print(f\"Fixed SQL succeeded: {success_fixed}\")\ndiff --git a/test_check_constraint.py b/test_check_constraint.py\nnew file mode 100644\nindex 0000000000..812c894ad1\n--- /dev/null\n+++ b/test_check_constraint.py\n@@ -0,0 +1,72 @@\n+#!/usr/bin/env python\n+\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes', \n+        'django.contrib.auth'\n+    ],\n+)\n+django.setup()\n+\n+from django.db import models, connection\n+from django.test import TestCase\n+from django.db.models.query_utils import Q\n+\n+class TestConstraintModel(models.Model):\n+    field_1 = models.IntegerField(blank=True, null=True)\n+    flag = models.BooleanField(blank=False, null=False)\n+    \n+    class Meta:\n+        constraints = [\n+            models.CheckConstraint(\n+                check=models.Q(flag__exact=True, field_1__isnull=False) | models.Q(flag__exact=False),\n+                name='field_1_has_value_if_flag_set'\n+            ),\n+        ]\n+        app_label = 'test_app'\n+\n+class CheckConstraintTest(TestCase):\n+    def test_check_constraint_sql(self):\n+        # Create a query for the model\n+        from django.db.models.sql.query import Query\n+        query = Query(model=TestConstraintModel)\n+        \n+        # Get the check constraint\n+        constraint = TestConstraintModel._meta.constraints[0]\n+        check = constraint.check\n+        \n+        # Build the WHERE clause\n+        where = query.build_where(check)\n+        compiler = query.get_compiler(connection=connection)\n+        sql, params = where.as_sql(compiler, connection)\n+        \n+        # Check the sql - it should not include table name qualification\n+        # for either AND or OR conditions\n+        print(\"SQL:\", sql)\n+        print(\"Params:\", params)\n+        \n+        # Assert that the SQL doesn't include table qualification in any part\n+        self.assertNotIn('\"test_app_testconstraintmodel\".\"field_1\"', sql)\n+        self.assertNotIn('\"test_app_testconstraintmodel\".\"flag\"', sql)\n+        \n+        # The correct form with SimpleCol for all fields\n+        expected_sql_parts = ['\"field_1\" IS NOT NULL', '\"flag\" = ']\n+        for part in expected_sql_parts:\n+            self.assertIn(part, sql)\n+\n+if __name__ == \"__main__\":\n+    # Run the test\n+    import unittest\n+    unittest.main()\n",
    "model_name_or_path": "claude-sonnet-3.7"
  }
]