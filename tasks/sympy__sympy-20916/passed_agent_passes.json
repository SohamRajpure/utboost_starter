[
  {
    "instance_id": "sympy__sympy-20916",
    "model_patch": "diff --git a/sympy/printing/conventions.py b/sympy/printing/conventions.py\nindex 9a3be6bbe9..ab10d56c87 100644\n--- a/sympy/printing/conventions.py\n+++ b/sympy/printing/conventions.py\n@@ -62,10 +62,21 @@ def split_super_sub(text):\n \n     # make a little exception when a name ends with digits, i.e. treat them\n     # as a subscript too.\n-    m = _name_with_digits_p.match(name)\n-    if m:\n-        name, sub = m.groups()\n-        subs.insert(0, sub)\n+    # First check if it's a Greek letter with a digit\n+    if len(name) > 1 and any(c.isdigit() for c in name):\n+        # Find the last non-digit character\n+        last_non_digit = max(i for i, c in enumerate(name) if not c.isdigit())\n+        base = name[:last_non_digit + 1]\n+        digits = name[last_non_digit + 1:]\n+        if digits:  # If we found any digits\n+            name = base\n+            subs.insert(0, digits)\n+    else:\n+        # Regular case for non-Greek letters\n+        m = _name_with_digits_p.match(name)\n+        if m:\n+            name, sub = m.groups()\n+            subs.insert(0, sub)\n \n     return name, supers, subs\n \ndiff --git a/sympy/printing/pretty/pretty_symbology.py b/sympy/printing/pretty/pretty_symbology.py\nindex 3f7c4a2dc7..a5ffb7b1b6 100644\n--- a/sympy/printing/pretty/pretty_symbology.py\n+++ b/sympy/printing/pretty/pretty_symbology.py\n@@ -518,17 +518,29 @@ def pretty_symbol(symb_name, bold_name=False):\n     name, sups, subs = split_super_sub(symb_name)\n \n     def translate(s, bold_name) :\n+        # First check if it's a Greek letter\n         if bold_name:\n             gG = greek_bold_unicode.get(s)\n         else:\n             gG = greek_unicode.get(s)\n         if gG is not None:\n             return gG\n+\n+        # Check for modifiers (like hat, tilde, etc.)\n         for key in sorted(modifier_dict.keys(), key=lambda k:len(k), reverse=True) :\n             if s.lower().endswith(key) and len(s)>len(key):\n                 return modifier_dict[key](translate(s[:-len(key)], bold_name))\n+\n+        # Check if it's a digit that should be subscripted\n+        if s.isdigit():\n+            subscript = ''.join(sub.get(c, c) for c in s)\n+            if all(c != s for s, c in zip(s, subscript)):  # Only use if we found subscripts for all chars\n+                return subscript\n+\n+        # If it's a bold name, convert to bold characters\n         if bold_name:\n             return ''.join([bold_unicode[c] for c in s])\n+\n         return s\n \n     name = translate(name, bold_name)\n@@ -538,10 +550,15 @@ def translate(s, bold_name) :\n     def pretty_list(l, mapping):\n         result = []\n         for s in l:\n+            # First try to get the whole string from the mapping\n             pretty = mapping.get(s)\n             if pretty is None:\n-                try:  # match by separate characters\n-                    pretty = ''.join([mapping[c] for c in s])\n+                # If that fails, try character by character\n+                try:\n+                    pretty = ''.join(mapping.get(c, c) for c in s)\n+                    # Only use the result if at least one character was mapped\n+                    if pretty == s:\n+                        return None\n                 except (TypeError, KeyError):\n                     return None\n             result.append(pretty)\n@@ -554,17 +571,32 @@ def pretty_list(l, mapping):\n         pretty_subs = None\n \n     # glue the results into one string\n-    if pretty_subs is None:  # nice formatting of sups/subs did not work\n-        if subs:\n-            name += '_'+'_'.join([translate(s, bold_name) for s in subs])\n-        if sups:\n-            name += '__'+'__'.join([translate(s, bold_name) for s in sups])\n-        return name\n-    else:\n-        sups_result = ' '.join(pretty_sups)\n-        subs_result = ' '.join(pretty_subs)\n-\n-    return ''.join([name, sups_result, subs_result])\n+    if subs:\n+        # Always try to convert subscripts to unicode characters first\n+        subs_result = ''\n+        for s in subs:\n+            # Try to convert each character to a subscript\n+            sub_chars = []\n+            for c in s:\n+                if c in sub:\n+                    sub_chars.append(sub[c])\n+                elif c.isdigit():  # Special case for digits\n+                    sub_chars.append(sub.get(c, c))\n+                else:\n+                    # If we find a non-digit that's not in sub, fall back to underscore\n+                    sub_chars = None\n+                    break\n+            if sub_chars:\n+                subs_result += ''.join(sub_chars)\n+            else:\n+                # Fall back to underscore notation for this part\n+                subs_result += '_' + translate(s, bold_name)\n+        name += subs_result\n+\n+    if sups:\n+        name += '__'+'__'.join([translate(s, bold_name) for s in sups])\n+\n+    return name\n \n \n def annotated(letter):\n",
    "model_name_or_path": "epam-ai-run"
  }
]