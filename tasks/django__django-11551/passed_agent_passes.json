[
  {
    "instance_id": "django__django-11551",
    "model_patch": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex f82c20c2f1..9fd77b5d41 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -720,33 +720,33 @@ class ModelAdminChecks(BaseModelAdminChecks):\n             return []\n         elif hasattr(obj, item):\n             return []\n-        elif hasattr(obj.model, item):\n+        else:\n             try:\n                 field = obj.model._meta.get_field(item)\n             except FieldDoesNotExist:\n-                return []\n-            else:\n-                if isinstance(field, models.ManyToManyField):\n+                try:\n+                    field = getattr(obj.model, item)\n+                except AttributeError:\n                     return [\n                         checks.Error(\n-                            \"The value of '%s' must not be a ManyToManyField.\" % label,\n+                            \"The value of '%s' refers to '%s', which is not a callable, \"\n+                            \"an attribute of '%s', or an attribute or method on '%s.%s'.\" % (\n+                                label, item, obj.__class__.__name__,\n+                                obj.model._meta.app_label, obj.model._meta.object_name,\n+                            ),\n                             obj=obj.__class__,\n-                            id='admin.E109',\n+                            id='admin.E108',\n                         )\n                     ]\n-                return []\n-        else:\n-            return [\n-                checks.Error(\n-                    \"The value of '%s' refers to '%s', which is not a callable, \"\n-                    \"an attribute of '%s', or an attribute or method on '%s.%s'.\" % (\n-                        label, item, obj.__class__.__name__,\n-                        obj.model._meta.app_label, obj.model._meta.object_name,\n-                    ),\n-                    obj=obj.__class__,\n-                    id='admin.E108',\n-                )\n-            ]\n+            if isinstance(field, models.ManyToManyField):\n+                return [\n+                    checks.Error(\n+                        \"The value of '%s' must not be a ManyToManyField.\" % label,\n+                        obj=obj.__class__,\n+                        id='admin.E109',\n+                    )\n+                ]\n+            return []\n \n     def _check_list_display_links(self, obj):\n         \"\"\" Check that list_display_links is a unique subset of list_display.\ndiff --git a/tests/admin_checks/test_fields.py b/tests/admin_checks/test_fields.py\nnew file mode 100644\nindex 0000000000..6b6f4be0a5\n--- /dev/null\n+++ b/tests/admin_checks/test_fields.py\n@@ -0,0 +1,88 @@\n+\n+from django.contrib.admin import ModelAdmin, AdminSite\n+from django.contrib.admin.checks import ModelAdminChecks\n+from django.core import checks\n+from django.db import models\n+from django.test import SimpleTestCase\n+\n+\n+class InstanceOnlyDescriptor:\n+    \"\"\"A descriptor that can only be accessed on model instances, not on the model class.\"\"\"\n+    def __init__(self, name):\n+        self.name = name\n+\n+    def __get__(self, instance, owner):\n+        if instance is None:\n+            raise AttributeError(f\"'{owner.__name__}' object has no attribute '{self.name}'\")\n+        return getattr(instance, f\"_{self.name}\", 0)\n+\n+    def __set__(self, instance, value):\n+        setattr(instance, f\"_{self.name}\", value)\n+\n+\n+class PositionField(models.Field):\n+    \"\"\"A dummy implementation of PositionField that uses an InstanceOnlyDescriptor.\"\"\"\n+    \n+    def __init__(self, *args, **kwargs):\n+        kwargs.setdefault('default', 0)\n+        super().__init__(*args, **kwargs)\n+        \n+    def contribute_to_class(self, cls, name):\n+        super().contribute_to_class(cls, name)\n+        setattr(cls, name, InstanceOnlyDescriptor(name))\n+\n+\n+class SpecialModel(models.Model):\n+    \"\"\"Model with a field that can only be accessed via instances.\"\"\"\n+    name = models.CharField(max_length=100)\n+    position = PositionField()\n+    \n+    class Meta:\n+        app_label = 'admin_checks'\n+\n+\n+class SpecialModelAdmin(ModelAdmin):\n+    list_display = ['name', 'position']\n+\n+\n+class CheckListDisplayTests(SimpleTestCase):\n+    def test_instance_only_descriptor_field(self):\n+        \"\"\"\n+        Fields that are accessible only via model instances (like PositionField)\n+        should not raise admin.E108.\n+        \"\"\"\n+        checks = ModelAdminChecks()\n+        admin_site = AdminSite()\n+        admin = SpecialModelAdmin(SpecialModel, admin_site)\n+        \n+        # Test the position field\n+        errors = checks._check_list_display_item(admin, 'position', 'list_display[1]')\n+        self.assertEqual(errors, [])\n+        \n+        # Test a regular field\n+        errors = checks._check_list_display_item(admin, 'name', 'list_display[0]')\n+        self.assertEqual(errors, [])\n+        \n+        # Test a non-existent field\n+        errors = checks._check_list_display_item(admin, 'non_existent', 'list_display[2]')\n+        self.assertEqual(len(errors), 1)\n+        self.assertEqual(errors[0].id, 'admin.E108')\n+        \n+    def test_many_to_many_field(self):\n+        \"\"\"ManyToManyField should raise admin.E109.\"\"\"\n+        class ModelWithM2M(models.Model):\n+            m2m = models.ManyToManyField('self')\n+            \n+            class Meta:\n+                app_label = 'admin_checks'\n+        \n+        class M2MAdmin(ModelAdmin):\n+            list_display = ['m2m']\n+        \n+        checks_obj = ModelAdminChecks()\n+        admin_site = AdminSite()\n+        admin = M2MAdmin(ModelWithM2M, admin_site)\n+        \n+        errors = checks_obj._check_list_display_item(admin, 'm2m', 'list_display[0]')\n+        self.assertEqual(len(errors), 1)\n+        self.assertEqual(errors[0].id, 'admin.E109')\n",
    "model_name_or_path": "claude-sonnet-3.7"
  }
]