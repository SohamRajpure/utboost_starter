[
  {
    "instance_id": "django__django-11179",
    "model_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..5353d10ade 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -263,22 +263,23 @@ class Collector:\n         # sort instance collections\n         for model, instances in self.data.items():\n             self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n-\n+    \n         # if possible, bring the models in an order suitable for databases that\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n-\n+    \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n-\n+    \n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n             for model, obj in self.instances_with_model():\n@@ -286,36 +287,36 @@ class Collector:\n                     signals.pre_delete.send(\n                         sender=model, instance=obj, using=self.using\n                     )\n-\n+    \n             # fast deletes\n             for qs in self.fast_deletes:\n                 count = qs._raw_delete(using=self.using)\n                 deleted_counter[qs.model._meta.label] += count\n-\n+    \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n                 for (field, value), instances in instances_for_fieldvalues.items():\n                     query = sql.UpdateQuery(model)\n                     query.update_batch([obj.pk for obj in instances],\n                                        {field.name: value}, self.using)\n-\n+    \n             # reverse instance collections\n             for instances in self.data.values():\n                 instances.reverse()\n-\n+    \n             # delete instances\n             for model, instances in self.data.items():\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n                 count = query.delete_batch(pk_list, self.using)\n                 deleted_counter[model._meta.label] += count\n-\n+    \n                 if not model._meta.auto_created:\n                     for obj in instances:\n                         signals.post_delete.send(\n                             sender=model, instance=obj, using=self.using\n                         )\n-\n+    \n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n             for (field, value), instances in instances_for_fieldvalues.items():\n@@ -325,3 +326,4 @@ class Collector:\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n         return sum(deleted_counter.values()), dict(deleted_counter)\n+    \ndiff --git a/test_pk_delete.py b/test_pk_delete.py\nnew file mode 100644\nindex 0000000000..d3d1ba17cd\n--- /dev/null\n+++ b/test_pk_delete.py\n@@ -0,0 +1,47 @@\n+import sys\n+import django\n+import traceback\n+from django.conf import settings\n+from django.db import models, connection\n+\n+print(\"Starting test script to verify if PK is cleared after delete with no dependencies.\")\n+try:\n+    settings.configure(\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:'\n+            }\n+        },\n+        INSTALLED_APPS=[],\n+        SECRET_KEY='test_secret_key'\n+    )\n+    django.setup()\n+\n+    class MyTestModel(models.Model):\n+        name = models.CharField(max_length=100)\n+\n+        class Meta:\n+            app_label = '__main__'  # no dependencies\n+\n+    # Create table.\n+    with connection.schema_editor() as editor:\n+        editor.create_model(MyTestModel)\n+\n+    # Create a model instance and delete it.\n+    obj = MyTestModel.objects.create(name='TestObj')\n+    print(f\"Created object with PK={obj.pk}\")\n+\n+    obj.delete()\n+    print(f\"Object PK after delete: {obj.pk}\")\n+    if obj.pk is not None:\n+        print(\"FAIL: PK is not cleared after .delete()\")\n+        sys.exit(1)\n+    else:\n+        print(\"PASS: PK is None after .delete()\")\n+        sys.exit(0)\n+\n+except Exception as e:\n+    print(\"ERROR during test execution!\")\n+    traceback.print_exc()\n+    sys.exit(2)\n",
    "model_name_or_path": "readytogo-crosschecked"
  }
]