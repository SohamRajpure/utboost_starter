[
  {
    "instance_id": "django__django-14559",
    "model_patch": "diff --git a/check_bulk_update_return_value.py b/check_bulk_update_return_value.py\nnew file mode 100644\nindex 0000000000..f2cd608608\n--- /dev/null\n+++ b/check_bulk_update_return_value.py\n@@ -0,0 +1,62 @@\n+import sys\n+import django\n+from django.conf import settings\n+from django.db import models, connection\n+from django.core.management import call_command\n+\n+DB_NAME = \":memory:\"\n+\n+# Minimal Django settings for an in-memory sqlite database.\n+settings.configure(\n+    INSTALLED_APPS=[],\n+    DATABASES={\n+        \"default\": {\n+            \"ENGINE\": \"django.db.backends.sqlite3\",\n+            \"NAME\": DB_NAME,\n+        }\n+    },\n+    SECRET_KEY=\"testsecretkey\",\n+)\n+\n+def main():\n+    print(\"Starting test for bulk_update return value.\")\n+    django.setup()\n+\n+    class BulkUpdateTestModel(models.Model):\n+        name = models.CharField(max_length=50)\n+        value = models.IntegerField()\n+\n+        class Meta:\n+            app_label = \"bulk_update_test_app\"  # Just a placeholder; no real migrations.\n+\n+    # Manually create the table for BulkUpdateTestModel.\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(BulkUpdateTestModel)\n+\n+    print(\"Creating objects...\")\n+    objs = [\n+        BulkUpdateTestModel.objects.create(name=\"obj1\", value=1),\n+        BulkUpdateTestModel.objects.create(name=\"obj2\", value=2),\n+        BulkUpdateTestModel.objects.create(name=\"obj3\", value=3),\n+    ]\n+\n+    for obj in objs:\n+        obj.value += 10\n+\n+    print(\"Calling bulk_update() on these objects...\")\n+    rows_updated = BulkUpdateTestModel.objects.bulk_update(objs, [\"value\"])\n+    print(f\"bulk_update() returned: {rows_updated!r}\")\n+\n+    # Expect an integer equal to the number of updated rows.\n+    if not isinstance(rows_updated, int):\n+        print(\"FAIL: bulk_update() did not return an integer.\")\n+        sys.exit(1)\n+    if rows_updated != len(objs):\n+        print(f\"FAIL: Expected {len(objs)} but got {rows_updated}\")\n+        sys.exit(1)\n+\n+    print(\"PASS: bulk_update() returned an integer matching the number of rows updated.\")\n+    sys.exit(0)\n+\n+if __name__ == \"__main__\":\n+    main()\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca527..792e74db7f 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -541,9 +541,7 @@ class QuerySet:\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\n-            return\n-        # PK is used twice in the resulting update query, once in the filter\n-        # and once in the WHEN. Each field will also have one CAST.\n+            return 0\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n         batch_size = min(batch_size, max_batch_size) if batch_size else max_batch_size\n         requires_casting = connections[self.db].features.requires_casted_case_in_updates\n@@ -563,9 +561,13 @@ class QuerySet:\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+        total_updated = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n-                self.filter(pk__in=pks).update(**update_kwargs)\n+                updated_count = self.filter(pk__in=pks).update(**update_kwargs)\n+                total_updated += updated_count\n+        return total_updated\n+    \n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n",
    "model_name_or_path": "readytogo-crosschecked"
  }
]